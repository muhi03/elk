import{aK as b,ct as u,A as D,a9 as C,bp as O,bf as B,cg as M,c5 as E,aa as H,cu as p,cv as R,cw as S,h as V}from"./vIUoIwJY.js";const K=t=>t==="defer"||t===!1;function T(...t){const i=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(i);let[s,f,e={}]=t;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=b(),g=f,P=()=>u.value,w=()=>a.isHydrating?a.payload.data[s]:a.static.data[s];e.server??=!0,e.default??=P,e.getCachedData??=w,e.lazy??=!1,e.immediate??=!0,e.deep??=u.deep,e.dedupe??="cancel";const d=e.getCachedData(s,a),h=d!=null;if(!a._asyncData[s]||!e.immediate){a.payload._errors[s]??=u.errorValue;const o=e.deep?D:C;a._asyncData[s]={data:o(h?d:e.default()),pending:D(!h),error:O(a.payload._errors,s),status:D("idle"),_default:e.default}}const r={...a._asyncData[s]};delete r._default,r.refresh=r.execute=(o={})=>{if(a._asyncDataPromises[s]){if(K(o.dedupe??e.dedupe))return a._asyncDataPromises[s];a._asyncDataPromises[s].cancelled=!0}if(o._initial||a.isHydrating&&o._initial!==!1){const c=o._initial?d:e.getCachedData(s,a);if(c!=null)return Promise.resolve(c)}r.pending.value=!0,r.status.value="pending";const l=new Promise((c,n)=>{try{c(g(a))}catch(y){n(y)}}).then(async c=>{if(l.cancelled)return a._asyncDataPromises[s];let n=c;e.transform&&(n=await e.transform(c)),e.pick&&(n=z(n,e.pick)),a.payload.data[s]=n,r.data.value=n,r.error.value=u.errorValue,r.status.value="success"}).catch(c=>{if(l.cancelled)return a._asyncDataPromises[s];r.error.value=S(c),r.data.value=V(e.default()),r.status.value="error"}).finally(()=>{l.cancelled||(r.pending.value=!1,delete a._asyncDataPromises[s])});return a._asyncDataPromises[s]=l,a._asyncDataPromises[s]},r.clear=()=>j(a,s);const _=()=>r.refresh({_initial:!0}),m=e.server!==!1&&a.payload.serverRendered;{const o=B();if(o&&m&&e.immediate&&!o.sp&&(o.sp=[]),o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const n=o._nuxtOnBeforeMountCbs;M(()=>{n.forEach(y=>{y()}),n.splice(0,n.length)}),E(()=>n.splice(0,n.length))}m&&a.isHydrating&&(r.error.value||d!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(a.payload.serverRendered&&a.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(_):e.immediate&&_();const l=R();if(e.watch){const n=H(e.watch,()=>r.refresh());l&&p(n)}const c=a.hook("app:data:refresh",async n=>{(!n||n.includes(s))&&await r.refresh()});l&&p(c)}const v=Promise.resolve(a._asyncDataPromises[s]).then(()=>r);return Object.assign(v,r),v}function j(t,i){i in t.payload.data&&(t.payload.data[i]=void 0),i in t.payload._errors&&(t.payload._errors[i]=u.errorValue),t._asyncData[i]&&(t._asyncData[i].data.value=void 0,t._asyncData[i].error.value=u.errorValue,t._asyncData[i].pending.value=!1,t._asyncData[i].status.value="idle"),i in t._asyncDataPromises&&(t._asyncDataPromises[i]&&(t._asyncDataPromises[i].cancelled=!0),t._asyncDataPromises[i]=void 0)}function z(t,i){const s={};for(const f of i)s[f]=t[f];return s}export{T as u};
